* Program generated by R&R Relational Report Writer Code Generator, Version 1.1
* Serial Number:    152462

* Program Name:     R_PROG.PRG
* Program Time:     13-Mar-92  8:15 PM
* Program Language: Clipper

* Report Library:   C:\MARJAN\MARJAN.RP1
* Report Name:      Lijst met programmatuur
* Report Time:      13-Mar-92  8:10 PM

BEGIN SEQUENCE
PRIVATE gn_lno, gn_slno, gn_pno, gn_lpno, gn_rno, gn_outcol, gn_break, gn_body
PRIVATE gl_eof, gl_fields, gl_cmpress, gl_blank, gl_wait, gl_body
PRIVATE gc_true, gc_false, gc_idate, gc_csign, gc_cpos, gc_tsep, gc_point
PRIVATE gc_dest, gc_printer, gc_orient, gn_indent, gn_pitch, gn_lpi, gn_pglen
PRIVATE gn_startpg, gn_endpg, gc_psff, gc_style
PRIVATE gc_str, gc_tag, gc_srt, gx_loscope, gx_hiscope
PRIVATE gn_head, gc_memx, gc_string, gc_color, gc_psreset
PRIVATE gn_key1, gn_key2, gn_key3, gn_key4, gn_key5
PRIVATE gc_key1, gc_key2, gc_key3, gc_key4, gc_key5

gn_lno = 1
gn_slno = 1
gn_pno = 1
gn_lpno = 1
gn_rno = 0
gl_eof = .F.
gl_fields = .F.
gc_dest = 'D'
gc_true = 'J'
gc_false = 'N'
gc_idate = 'B'
gc_csign = 'Ÿ'
gc_cpos = 'L'
gc_tsep =  '.'
gc_point = ','
gn_break = 0
gc_color = ''
gn_outcol = 0
gn_head = 0
gc_printer = 'A'
gc_style = 'bui00'
gn_startpg = 1
gn_endpg = 9999
gl_cmpress = .T.
gl_blank = .T.
gl_wait = .F.
gl_body = .T.
gc_orient = 'P'
gn_indent = 0
gn_pitch = 0
gn_lpi = 6
gn_pglen = 64
gc_psff = ''
gc_psreset = ''
gn_key1 = 0
gc_key1 = ''
gn_key2 = 0
gc_key2 = ''
gn_key3 = 0
gc_key3 = ''
gn_key4 = 0
gc_key4 = ''
gn_key5 = 0
gc_key5 = ''
gx_loscope = ''
gx_hiscope = ''

PRIVATE F[17]

PRIVATE Mwrap[12]

DO set1
DO clrc
DO gfr
IF m->gl_eof
	SET CONSOLE ON
	? 'No records found' + chr(7)
	SET PRINT OFF
	WAIT
	DO esc
ENDIF
IF m->gc_printer $ '12345678' .AND. m->gc_dest # 'D'
	IF FILE('rr_pr'+gc_printer+'.mem')
		RESTORE FROM rr_pr&gc_printer ADDITIVE
	ELSE
		gc_printer = 'A'
	ENDIF
ENDIF
DO set2
DO fld
DO ttl
DO head

* main program
DO WHILE .T.
	IF INKEY() = 27 .OR. LASTKEY() = 27
		DO esc
	ENDIF
	DO body
	DO gnr
	gl_fields = .F.
	DO CASE
		CASE m->gl_eof
			gl_fields = .T.
			EXIT
		OTHERWISE
			gn_break = 9
	ENDCASE
ENDDO

* termination
IF m->gn_lno <> 1
	DO foot
ENDIF
DO ff
IF m->gc_dest = 'D'
	WAIT
ENDIF
DO rset
END
RETURN

* --------------
* * procedures *
* --------------

**************************
PROCEDURE set1
* set environment, phase 1
**************************
gc_color = SETCOLOR()
SET CONSOLE ON
SET PRINT OFF
SET CENTURY OFF
SET DELETED OFF
SET EXACT OFF
SET MARGIN TO 0
SET SAFETY OFF

DO CASE
	CASE m->gc_idate = 'A'
		SET DATE AMERICAN
	CASE m->gc_idate = 'B'
		SET DATE BRITISH
	CASE m->gc_idate = 'C'
		SET DATE GERMAN
	CASE m->gc_idate = 'D'
		SET DATE ANSI
ENDCASE
RETURN

**************************
PROCEDURE set2
* set environment, phase 2
**************************
DO CASE
	CASE m->gc_dest = 'P'
		SET CONSOLE OFF
		SET PRINT ON
		IF m->gc_printer = 'A'
			SET PRINTER TO PRN
		ELSE
			SET PRINTER TO &gc_psoutp
		ENDIF
	CASE m->gc_dest = 'D'
		SET CONSOLE ON
		SET PRINT OFF
		SET STATUS OFF
	CASE m->gc_dest = 'F'
		SET CONSOLE OFF
		SET PRINTER TO NUL
		SET PRINT ON
ENDCASE
IF m->gc_dest <> 'D' .AND. m->gc_printer <> 'A'
	?? m->gc_pssetup
	?? IIF(m->gc_orient = 'P', m->gc_psport, m->gc_psland)
	?? IIF(m->gn_pitch = 10, m->gc_ps10cpi, IIF(m->gn_pitch =	12, ;
		m->gc_ps12cpi, m->gc_pscompr))
	?? IIF(m->gn_lpi = 6, m->gc_ps6lpi, m->gc_ps8lpi)
	?? IIF(''#m->gc_psflen, m->gc_psflen+CHR(m->gn_pglen % 256), '')
ENDIF
RETURN

*******************
PROCEDURE rset
* reset environment
*******************
CLOSE ALL
IF LEN(m->gc_psreset) <> 0
	?? m->gc_psreset
ENDIF
SETCOLOR(m->gc_color)
SET CONSOLE ON
SET PRINT OFF
SET DEVICE TO SCREEN
RETURN

*************
PROCEDURE esc
* escape key
*************
DO rset
BREAK

************************
PROCEDURE clrc
* clear composite record
************************
F[1] = CTOD('  /  /  ')
F[2] = CTOD('  /  /  ')
F[3] = ''
F[4] = ''
F[16] = 0
F[17] = 0
RETURN

*****************
PROCEDURE ff
* print form feed
*****************
IF m->gn_lno = 1
	RETURN
ENDIF
IF m->gn_pno >= m->gn_startpg
	DO CASE
		CASE m->gc_dest = 'D'
			?? REPLICATE(CHR(196),80)
		CASE m->gc_printer = 'A' .OR. LEN(m->gc_psff) = 0
			DO WHILE m->gn_lno < 65
				?
				gn_lno = m->gn_lno + 1
				gn_outcol = 0
			ENDDO
		CASE m->gn_lno < 65
			?? m->gc_psff
	ENDCASE
ENDIF
gn_pno = m->gn_pno + 1
gn_lpno = m->gn_lpno + 1
gn_lno = 1
IF m->gn_pno > m->gn_endpg
	IF m->gc_dest = 'D'
		WAIT
	ENDIF
	DO esc
ENDIF
RETURN

******************
PROCEDURE topm
* print top margin
******************
IF m->gc_dest = 'P' .AND. m->gl_wait
	SET CONSOLE ON
	SET PRINT OFF
	@ 24,0
	@ 24,0 SAY 'Wait between pages, press any key to continue...'
	WAIT
	SET CONSOLE OFF
	SET PRINT ON
ENDIF
* re-calculate page number fields
F[17] = PAGENO()
F[16] = F[17]
RETURN

***********************
PROCEDURE newp
* check for top of page
***********************
IF m->gn_lno = 1
	DO topm
	DO head
ENDIF
RETURN

***********************
PROCEDURE endp
* check for end of page
***********************
IF m->gn_lno > 62
	DO foot
	DO ff
	DO fld
	DO newp
ENDIF
RETURN

*************
PROCEDURE ttl
* print title
*************
DO topm
?? SPACE(51)
DO rr_outfsz WITH 'Programmalijst', 'BUi00'
gn_outcol = 65
?? SPACE(1)
DO rr_outfsz WITH 'd.d.', 'BUi00'
gn_outcol = 70
?? SPACE(1)
DO rr_outfsz WITH edit_da(F[1],9), 'BUi00'
?
gn_lno = m->gn_lno + 1
gn_outcol = 0
?
gn_lno = m->gn_lno + 1
gn_outcol = 0
RETURN

*******************
PROCEDURE head
* print page header
*******************
Mwrap[1] = 1
Mwrap[4] = ''
DO rr_outfsz WITH 'Programma', 'Bui00'
gn_outcol = 9
?? SPACE(24)
DO rr_outfsz WITH 'DiskNr', 'Bui00'
gn_outcol = 39
?? SPACE(1)
DO rr_outfsz WITH 'Disks', 'Bui00'
gn_outcol = 45
?? SPACE(2)
DO rr_outfsz WITH 'Media', 'Bui00'
gn_outcol = 52
?? SPACE(3)
DO rr_outfsz WITH 'Capac.', 'Bui00'
gn_outcol = 61
?? SPACE(2)
DO rr_outfsz WITH 'Categorie', 'Bui00'
gn_outcol = 72
?? SPACE(12)
DO rr_outfsz WITH 'Archive/Backup', 'Bui00'
?
gn_lno = m->gn_lno + 1
gn_outcol = 0
DO rr_cwrap WITH F[3],80,1,0
?? Mwrap[2]
?
gn_lno = m->gn_lno + 1
gn_outcol = 0
RETURN

*******************
PROCEDURE foot
* print page footer
*******************
DO WHILE m->gn_lno < 63
	?
	gn_lno = m->gn_lno + 1
	gn_outcol = 0
ENDDO
Mwrap[5] = 1
Mwrap[8] = ''
DO rr_cwrap WITH F[3],80,5,0
?? Mwrap[6]
?
gn_lno = m->gn_lno + 1
gn_outcol = 0
?? SPACE(60)
DO rr_outfsz WITH 'Pagina', 'Bui00'
gn_outcol = 66
?? SPACE(1)
DO rr_outfsz WITH edit_fp(F[16],4,0,' 0F'), 'Bui00'
?
gn_lno = m->gn_lno + 1
gn_outcol = 0
RETURN

**************************
PROCEDURE fld
* move data to field array
**************************
IF m->gl_fields
	RETURN
ENDIF
F[5] = PROGRAMS->NAME
F[6] = PROGRAMS->DISKNR
F[7] = PROGRAMS->MERK
F[8] = PROGRAMS->DISKS
F[9] = PROGRAMS->ARCNR
F[10] = PROGRAMS->CATNR
F[11] = DISKNRS->TYPENR
F[12] = TYPENRS->MEDIA
F[13] = TYPENRS->CAPACITY
F[14] = ARCNRS->ARCNAME
F[15] = CATEGORY->CATEGORY
F[1] = F[2]
F[3] = F[4]
F[16] = F[17]
gl_fields = .T.
RETURN

******************
PROCEDURE body
* print body lines
******************
gn_head = 0
IF .NOT. m->gl_body
	DO fld
	RETURN
ENDIF
IF m->gn_lno > 62
	DO foot
	DO ff
ENDIF
DO fld
DO newp
Mwrap[9] = 1
Mwrap[12] = ''
DO endp
gc_string = RTRIM(LEFT(F[5],30))
?? m->gc_string
gn_outcol = LEN(m->gc_string)
?? SPACE(31 - m->gn_outcol)
?? '³'
gn_outcol = 32
gc_string = RTRIM(LEFT(F[6],5))
?? SPACE(1)
?? m->gc_string
gn_outcol = 33 + LEN(m->gc_string)
?? SPACE(39 - m->gn_outcol)
?? '³'
gn_outcol = 40
gc_string = edit_fp(F[8],2,0,' 0F')
?? SPACE(2)
?? m->gc_string
gn_outcol = 42 + LEN(m->gc_string)
?? SPACE(45 - m->gn_outcol)
?? '³'
gn_outcol = 46
gc_string = RTRIM(LEFT(F[12],5))
?? SPACE(1)
?? m->gc_string
gn_outcol = 47 + LEN(m->gc_string)
?? SPACE(53 - m->gn_outcol)
?? '³'
gn_outcol = 54
gc_string = RTRIM(LEFT(F[13],5))
?? SPACE(1)
?? m->gc_string
gn_outcol = 55 + LEN(m->gc_string)
?? SPACE(61 - m->gn_outcol)
?? '³'
gn_outcol = 62
DO rr_cwrap WITH F[15],18,9,0
?? SPACE(1)
?? Mwrap[10]
gn_outcol = 63 + LEN(Mwrap[10])
?? SPACE(82 - m->gn_outcol)
?? '³'
gn_outcol = 83
?? SPACE(1)
?? RTRIM(LEFT(F[14],20))
?
gn_lno = m->gn_lno + 1
gn_outcol = 0
DO WHILE .T.
	DO rr_cwrap WITH F[15],18,9,0
	IF .NOT. (Mwrap[11])
		EXIT
	ENDIF
	DO endp
	?? SPACE(63)
	?? Mwrap[10]
	gn_outcol = m->gn_outcol + LEN(Mwrap[10])
	?
	gn_lno = m->gn_lno + 1
	gn_outcol = 0
ENDDO
RETURN

****************************
PROCEDURE gfr
* get first composite record
****************************
SELECT 1
USE PROGRAMS.DBF ALIAS PROGRAMS INDEX PROGNAME.NTX
gc_key1 = INDEXKEY(1)
gn_key1 = LEN(&gc_key1)
SELECT 2
USE DISKNRS.DBF ALIAS DISKNRS INDEX DISKNR.NTX
gc_key2 = INDEXKEY(1)
gn_key2 = LEN(&gc_key2)
SELECT 3
USE TYPENRS.DBF ALIAS TYPENRS INDEX TYPENR.NTX
gc_key3 = INDEXKEY(1)
SELECT 4
USE ARCNRS.DBF ALIAS ARCNRS INDEX ARCNR.NTX
gc_key4 = INDEXKEY(1)
SELECT 5
USE CATEGORY.DBF ALIAS CATEGORY INDEX CATEGORY.NTX
gc_key5 = INDEXKEY(1)
gn_rno = 1
F[2] = DATE()
F[4] = REPLICATE("Ä",104)
DO gfr0
DO WHILE .T.
	IF m->gl_eof
		RETURN
	ENDIF
	IF query()
		RETURN
	ENDIF
	DO gnr0
ENDDO

***************************
PROCEDURE gnr
* get next composite record
***************************
gn_rno = m->gn_rno + 1
DO WHILE .T.
	DO gnr0
	IF m->gl_eof
		RETURN
	ENDIF
	IF query()
		RETURN
	ENDIF
ENDDO

*************************************
PROCEDURE gfr0
* get first composite record, level 0
*************************************
gl_eof = .F.
SELECT PROGRAMS
DO WHILE .T.
	IF EOF()
		gl_eof = .T.
		RETURN
	ENDIF
	SELECT DISKNRS
	SET SOFTSEEK OFF
	SEEK rr_seek(PROGRAMS->DISKNR,5,m->gn_key2)
	SELECT TYPENRS
	SET SOFTSEEK OFF
	SEEK DISKNRS->TYPENR
	SELECT ARCNRS
	SET SOFTSEEK OFF
	SEEK PROGRAMS->ARCNR
	SELECT CATEGORY
	SET SOFTSEEK OFF
	SEEK PROGRAMS->CATNR
	F[17] = PAGENO()
	EXIT
ENDDO
RETURN

************************************
PROCEDURE gnr0
* get next composite record, level 0
************************************
gl_eof = .F.
DO WHILE .T.
	SELECT PROGRAMS
	SKIP
	IF EOF()
		gl_eof = .T.
		RETURN
	ENDIF
	SELECT DISKNRS
	SET SOFTSEEK OFF
	SEEK rr_seek(PROGRAMS->DISKNR,5,m->gn_key2)
	SELECT TYPENRS
	SET SOFTSEEK OFF
	SEEK DISKNRS->TYPENR
	SELECT ARCNRS
	SET SOFTSEEK OFF
	SEEK PROGRAMS->ARCNR
	SELECT CATEGORY
	SET SOFTSEEK OFF
	SEEK PROGRAMS->CATNR
	F[17] = PAGENO()
	EXIT
ENDDO
RETURN

****************************************************
PROCEDURE rr_cwrap
PARAMETERS lc_string, ln_width, ln_windex, ln_format
* next wrapped character field
****************************************************
PRIVATE lc_f, lc_s, ln_l, ln_k, ll_full
DO WHILE .T.
	IF Mwrap[m->ln_windex] > LEN(m->lc_string)
		Mwrap[m->ln_windex+1] = ''
		Mwrap[m->ln_windex+2] = .F.
		Mwrap[m->ln_windex+3] = ''
		RETURN
	ENDIF
	IF LEN(Mwrap[m->ln_windex+3]) = 0 .OR. SUBSTR(m->lc_string,Mwrap[;
		m->ln_windex],1) <> ' '
		EXIT
	ENDIF
	Mwrap[m->ln_windex] = Mwrap[m->ln_windex] + 1
ENDDO
lc_f = SUBSTR(m->lc_string,Mwrap[m->ln_windex],m->ln_width+1)
ln_l = LEN(m->lc_f)
ln_k = AT(';',m->lc_f)
ll_full = m->ln_k = 0 .AND. m->ln_l > m->ln_width
Mwrap[m->ln_windex+3] = IIF(m->ll_full,';','')
IF m->ln_k = 0
	IF m->ln_l <= m->ln_width
		lc_f = m->lc_f + ' '
		ln_l = m->ln_l + 1
	ENDIF
	ln_k = m->ln_l - 1
	DO WHILE .T.
		IF SUBSTR(m->lc_f,m->ln_k+1,1) = ' '
			Mwrap[m->ln_windex] = Mwrap[m->ln_windex] + m->ln_k + 1
			EXIT
		ENDIF
		IF SUBSTR(m->lc_f,m->ln_k+1,1) = '-' .AND. SUBSTR(m->lc_f,m->ln_k,1) ;
			<> ' ' .AND. SUBSTR(m->lc_f,m->ln_k,1) <> '('
			Mwrap[m->ln_windex] = Mwrap[m->ln_windex] + m->ln_k + 1
			ln_k = m->ln_k + 1
			EXIT
		ENDIF
		ln_k = m->ln_k - 1
		IF m->ln_k = 0
			ln_k = m->ln_l - 1 
			Mwrap[m->ln_windex] = Mwrap[m->ln_windex] + m->ln_k
			EXIT
		ENDIF
	ENDDO
ELSE
	Mwrap[m->ln_windex] = Mwrap[m->ln_windex] + m->ln_k
	ln_k = m->ln_k - 1
ENDIF
lc_f = RTRIM(LEFT(m->lc_f,m->ln_k))
ln_k = LEN(m->lc_f)
DO CASE
	CASE m->ln_format = 0
	CASE m->ln_format = 1
		lc_s = ''
		DO WHILE m->ll_full .AND. m->ln_k < m->ln_width
			ln_l = AT(' ',m->lc_f)
			IF m->ln_l = 0
				IF LEN(m->lc_s) = 0
					EXIT
				ENDIF
				lc_f = m->lc_s + m->lc_f
				lc_s = ''
				LOOP
			ENDIF
			lc_s = m->lc_s + LEFT(m->lc_f,m->ln_l)
			lc_f = SUBSTR(m->lc_f,m->ln_l+1)
			DO WHILE AT(' ',m->lc_f)=1
				lc_s = m->lc_s + ' '
				lc_f = SUBSTR(m->lc_f,2)
			ENDDO
			lc_s = m->lc_s + ' '
			ln_k = m->ln_k + 1
		ENDDO
		lc_f = m->lc_s + m->lc_f
	CASE m->ln_format = 2
		lc_f = SPACE(m->ln_width - m->ln_k) + m->lc_f
	ENDCASE
Mwrap[m->ln_windex + 1] = m->lc_f
Mwrap[m->ln_windex+2] = .T.
RETURN

******************************************
PROCEDURE rr_outfsz
PARAMETERS lc_string, lc_style
* output string with style/font attributes
******************************************
PRIVATE ln_l, ln_n
ln_l = LEN(m->lc_string)
IF m->ln_l = 0
	RETURN
ENDIF
ln_n = m->ln_l - LEN(LTRIM(m->lc_string))
?? SPACE(m->ln_n)
DO rr_style WITH m->lc_style
?? LTRIM(m->lc_string)
DO rr_style WITH 'bui00'
RETURN

**************************************************
PROCEDURE rr_style
PARAMETERS lc_style
* change print style including attributes and font
**************************************************
PRIVATE lc_color, lc_font, lc_oldfon, lc_newfon
IF m->gc_dest = 'D'
	lc_color = 'w'
	IF SUBSTR(m->lc_style, 2, 1) = 'U'
		lc_color = 'U'
	ENDIF
	IF LEFT(m->lc_style, 1) = 'B'
		lc_color = m->lc_color + '+'
	ENDIF
	SET COLOR TO &lc_color.
ELSE
	IF m->gc_printer <> 'A'
		?? IIF(LEFT(m->lc_style, 1) # LEFT(m->gc_style, 1),  IIF(LEFT(;
			m->lc_style, 1) = 'B', m->gc_psbdon, m->gc_psbdoff),'')
		?? IIF(SUBSTR(m->lc_style, 2, 1) # SUBSTR(m->gc_style, 2, 1), IIF(;
			SUBSTR(m->lc_style, 2, 1) = 'U',m->gc_psulon,m->gc_psuloff),'')
		?? IIF(SUBSTR(m->lc_style, 3, 1) # SUBSTR(m->gc_style, 3, 1), IIF(;
			SUBSTR(m->lc_style, 3, 1) = 'I',m->gc_psiton,m->gc_psitoff),'')
		lc_oldfon = RIGHT(m->gc_style, 2)
		lc_newfon = RIGHT(m->lc_style, 2)
		?? IIF(m->lc_oldfon # m->lc_newfon, IIF(m->lc_newfon = '00', ;
			m->gc_psf&lc_oldfon.of, m->gc_psf&lc_newfon.on), '')
		gc_style = m->lc_style
	ENDIF
ENDIF
RETURN

**********************************
FUNCTION query
* query and 'print which' function
**********************************
ll_q0 = PROGRAMS->MERK
RETURN ll_q0 .AND. .NOT. (PROGRAMS->(DELETED()) .OR. DISKNRS->(DELETED()) ;
	.OR. TYPENRS->(DELETED()) .OR. ARCNRS->(DELETED()) .OR. CATEGORY->(;
	DELETED()))

*********************************
FUNCTION edit_da
PARAMETERS ld_date, ln_format
* edit date to abbreviated format
*********************************
IF m->ld_date = CTOD('  /  /  ')
	RETURN ''
ENDIF
PRIVATE lc_ret, lc_month, lc_year, lc_day
lc_year = RIGHT('000' + LTRIM(STR(YEAR(m->ld_date),4)),4)
IF m->ln_format > 5
	lc_year = RIGHT(m->lc_year,2)
	ln_format = m->ln_format - 5
ENDIF
lc_day = RIGHT('0' + LTRIM(STR(DAY(m->ld_date),2)),2)
DO CASE
	CASE m->ln_format < 4
		lc_month = LEFT(CMONTH(m->ld_date),3)
		DO CASE
			CASE m->ln_format = 1
				lc_ret = m->lc_day + '-' + m->lc_month + '-' + m->lc_year
			CASE m->ln_format = 2
				lc_ret = m->lc_day + '-' + m->lc_month
			CASE m->ln_format = 3
				lc_ret = m->lc_month + '-' + m->lc_year
		ENDCASE
	OTHERWISE
		lc_month = RIGHT('0' + LTRIM(STR(MONTH(m->ld_date),2)),2)
		DO CASE
			CASE m->gc_idate = 'A'
				lc_ret = m->lc_month + '/' + m->lc_day + IIF(m->ln_format=4,;
					'/' + m->lc_year,'')
			CASE m->gc_idate = 'B'
				lc_ret = m->lc_day + '/' + m->lc_month + IIF(m->ln_format=4,;
					'/' + m->lc_year,'')
			CASE m->gc_idate = 'C'
				lc_ret = m->lc_day + '.' + m->lc_month + IIF(m->ln_format=4,;
					'.' + m->lc_year,'')
			CASE m->gc_idate = 'D'
				lc_ret = + IIF(m->ln_format=4,m->lc_year+'-','') + ;
					m->lc_month + '-' + m->lc_day 
		ENDCASE
ENDCASE
RETURN m->lc_ret

********************************************
FUNCTION edit_fp
PARAMETERS ln_num, ln_ints, ln_decs, lc_type
* edit number to Fixed or Percent format
********************************************
PRIVATE lc_ret
IF RIGHT(m->lc_type,1) = 'P'
	ln_num = m->ln_num * 100
ENDIF
ln_num = ROUND(m->ln_num,m->ln_decs)
DO CASE
	CASE m->ln_num = 0 .AND. m->ln_ints = 0
		lc_ret = '.' + REPLICATE('0', m->ln_decs)
	CASE m->ln_num < 0
		lc_ret = TRANSFORM(m->ln_num, (REPLICATE('9', m->ln_ints + 1) + IIF(;
			m->ln_decs > 0, '.' + REPLICATE('9', m->ln_decs), '')))
		IF LEFT(m->lc_ret,1) # '-'
			lc_ret = STUFF(m->lc_ret, 1, 1, '')
		ENDIF
	OTHERWISE
		lc_ret = TRANSFORM(m->ln_num, (IIF(m->ln_ints>0, REPLICATE('9',;
			m->ln_ints), '') + IIF(m->ln_decs > 0, '.' + REPLICATE('9',;
			m->ln_decs), '')))
ENDCASE
IF m->gc_point # '.' .AND. AT('.',m->lc_ret) > 0
	lc_ret = STRTRAN(m->lc_ret, '.', m->gc_point)
ENDIF
IF RIGHT(m->lc_type,1) = 'P'
	lc_ret = m->lc_ret + '%'
ENDIF
IF RIGHT(m->lc_type,1) = 'F' .AND. m->ln_decs = 0 .AND. LEFT(m->lc_type,1) = '0'
	lc_ret = REPLICATE('0',LEN(m->lc_ret) - LEN(LTRIM(m->lc_ret))) + LTRIM(;
		m->lc_ret)
	IF '-'$m->lc_ret
		lc_ret = '-' + STUFF(m->lc_ret, AT('-', m->lc_ret), 1, '')
	ENDIF
ENDIF
IF m->ln_num<1 .AND. m->ln_num>-1 .AND. m->ln_ints>0 .AND. m->ln_decs>0
	IF SUBSTR(m->lc_ret,AT(m->gc_point,m->lc_ret)-1,1) <> '0'
		lc_ret = STUFF(m->lc_ret, AT(m->gc_point, m->lc_ret), 0, '0')
		IF LEFT(m->lc_ret, 1) = ' '
			lc_ret = STUFF(m->lc_ret, 1, 1, '')
		ENDIF
	ENDIF
ENDIF
IF VAL(m->lc_ret) = 0
	DO CASE
		CASE SUBSTR(m->lc_type,2,1) = ' '
			lc_ret = REPLICATE(' ', LEN(m->lc_ret))
		CASE '-' $ m->lc_ret
			lc_ret = STUFF(m->lc_ret, AT('-', m->lc_ret), 1, '')
	ENDCASE
ENDIF
RETURN m->lc_ret

***************
FUNCTION pageno
* page number
***************
RETURN m->gn_lpno

*************************************
FUNCTION rr_seek
PARAMETERS lc_string, ln_fl, ln_kl
* adjust seek string to proper length
*************************************
PRIVATE ln_k
ln_k = LEN(m->lc_string)
IF m->ln_k < m->ln_fl
	lc_string = lc_string + SPACE(m->ln_fl - m->ln_k)
ENDIF
lc_string = LEFT(m->lc_string,m->ln_kl)
RETURN lc_string
